#include <IO/CgnsReader2D.hpp>
 
// void ReadGrid::ReadCgnsGrid2D(std::string Path, int base, int zone, GridDataShared gridData) {
void CgnsReader2D(std::string Path, int base, int zone, GridDataShared gridData) {
	std::string problemfile = Path + "/Grid.cgns";
    int cgfile;
	cg_open(problemfile.c_str(), CG_MODE_READ, &cgfile);

	int nSections;
	if (cg_nsections(cgfile, base, zone, &nSections) != CG_OK) {
		std::cerr << "\nThere was a problem when reading sections" << std::endl;	cg_error_exit();
	}
	std::vector<int> bfe, wfe, aHee;
	int nRegions = 0;
	std::vector<std::string> rNames;

	// Loop over the number of sections and read the element connectivities.
	// As CGNS starts the numbering at 1 the for-loop starts at 1 as well.
	gridData->thickness = 1.0;
	std::vector<std::vector<int>> aTri, aQua, aBar;
	std::vector<int> rTri, rQua;
	char buf[800] = "NULL";
	
	for (int section = 1; section <= nSections; section++) {
		ElementType_t type;
		cgsize_t eBeg, eEnd; 
		int nBdry, parentFlag;
		std::vector<cgsize_t> conn;
		// Determines the element type and set the pointer for the connectivity accordingly.
		if (cg_section_read(cgfile, base, zone, section, buf, &type, &eBeg, &eEnd, &nBdry, &parentFlag) != CG_OK) {
			std::cerr << "\nThere was a problem when reading section" << section << std::endl;	cg_error_exit();
		}
		int eSize = eEnd - eBeg + 1;
		// Reads connectivity and builds auxiliar connectivity matrices for different element types
		switch(type) {
			case MIXED: {
				cgsize_t connSize; 
				int npe;
				cg_ElementDataSize(cgfile, base, zone, section, &connSize);
				conn.resize(connSize);
				cg_elements_read(cgfile, base, zone, section, &conn[0], 0);
				int i = 0;
				for (int e = 0; e < eSize; ++e) {
					cg_npe(ElementType_t(conn[i]), &npe);
					std::vector<int> aux(npe);
					for (int k = 0; k < npe; ++k) aux[k] = conn[i+1+k]-1;
					switch(conn[i]) {
						case TRI_3:
							aTri.push_back(aux);	rTri.push_back(nRegions);		break;
						case QUAD_4:
							aQua.push_back(aux);	rQua.push_back(nRegions);		break;
					}
					i += npe + 1;
				}
				rNames.push_back(buf);
				nRegions++;
				break; 
			}
			case TRI_3: {
				int npe = 3;	conn.resize(npe*eSize);
				cg_elements_read(cgfile, base, zone, section, &conn[0], 0);
				std::vector<int> aux(npe);
				for (int e = 0; e < eSize; ++e) {
					for (int k = 0; k < npe; ++k) aux[k] = conn[e*npe+k]-1;
					aTri.push_back(aux);	rTri.push_back(nRegions);		
				}
				break; 
			}
			case QUAD_4: {
				int npe = 4;	conn.resize(npe*eSize);
				cg_elements_read(cgfile, base, zone, section, &conn[0], 0);
				std::vector<int> aux(npe);
				for (int e = 0; e < eSize; ++e) {
					for (int k = 0; k < npe; ++k) aux[k] = conn[e*npe+k]-1;
					aQua.push_back(aux);	rQua.push_back(nRegions);		
				}
				break; 
			}
			case BAR_2: {
				int npe = 2;	conn.resize(npe*eSize);
				BoundaryData newBoun;
				newBoun.lineConnectivity.resize(eSize, std::vector<int>(npe));
				cg_elements_read(cgfile, base, zone, section, &conn[0], 0);
				for (int e = 0; e < eSize; ++e) 
					for (int k = 0; k < npe; ++k) 
						newBoun.lineConnectivity[e][k] = conn[e*npe+k]-1;
				newBoun.name = buf;
				gridData->boundaries.push_back(newBoun);
				bfe.push_back(eBeg);
				break; 
			}
			case NODE: {
				int npe = 2;	conn.resize(npe*eSize);
				WellData newWell;
				cg_elements_read(cgfile, base, zone, section, &conn[0], 0);
				newWell.wellNode = conn[0];
				newWell.name = buf;
				gridData->wells.push_back(newWell);
				wfe.push_back(eBeg);
				break; 
			}
			default:
				std::cout << "\nUnsupported element encountered" << std::endl;	cg_error_exit();
				break;
		}
	}
	// Store connectivity information into internal data structure.
	gridData->triangleConnectivity.resize(aTri.size(), std::vector<int>(3));
	for (int j = 0; j < aTri.size(); ++j) 
		for (int k = 0; k < 3; ++k) 
			gridData->triangleConnectivity[j][k] = aTri[j][k];

	gridData->quadrangleConnectivity.resize(aQua.size(), std::vector<int>(4));
	for (int j = 0; j < aQua.size(); ++j) 
		for (int k = 0; k < 4; ++k) 
			gridData->quadrangleConnectivity[j][k] = aQua[j][k];

	// Build data structure for regions
	gridData->regions.resize(nRegions);
	if (nRegions > 0) {
		int fi = 0;
		for (int e = 0; e < rTri.size(); ++e) {
			gridData->regions[ rTri[e] ].elementsOnRegion.push_back(fi + e);
		}
		fi += rTri.size();
		for (int e = 0; e < rQua.size(); ++e) {
			gridData->regions[ rQua[e] ].elementsOnRegion.push_back(fi + e);
		}
	}

	for (int r = 0; r < nRegions; ++r) {
		gridData->regions[r].name = rNames[r];
	}

    cg_close(cgfile);
}